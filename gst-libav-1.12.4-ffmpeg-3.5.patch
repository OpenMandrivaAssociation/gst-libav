--- gst-libav-1.12.4/ext/libav/gstavauddec.c.omv~	2018-01-11 15:25:56.469661379 +0100
+++ gst-libav-1.12.4/ext/libav/gstavauddec.c	2018-01-11 15:26:15.288737824 +0100
@@ -283,7 +283,7 @@ gst_ffmpegauddec_propose_allocation (Gst
   gst_allocation_params_init (&params);
   params.flags = GST_MEMORY_FLAG_ZERO_PADDED;
   params.align = 15;
-  params.padding = FF_INPUT_BUFFER_PADDING_SIZE;
+  params.padding = AV_INPUT_BUFFER_PADDING_SIZE;
   /* we would like to have some padding so that we don't have to
    * memcpy. We don't suggest an allocator. */
   gst_query_add_allocation_param (query, NULL, &params);
@@ -665,7 +665,7 @@ gst_ffmpegauddec_drain (GstFFMpegAudDec
 
   oclass = (GstFFMpegAudDecClass *) (G_OBJECT_GET_CLASS (ffmpegdec));
 
-  if (oclass->in_plugin->capabilities & CODEC_CAP_DELAY) {
+  if (oclass->in_plugin->capabilities & AV_CODEC_CAP_DELAY) {
     gint have_data, len;
 
     GST_LOG_OBJECT (ffmpegdec,
@@ -744,10 +744,10 @@ gst_ffmpegauddec_handle_frame (GstAudioD
   bsize = map.size;
 
   if (bsize > 0 && (!GST_MEMORY_IS_ZERO_PADDED (map.memory)
-          || (map.maxsize - map.size) < FF_INPUT_BUFFER_PADDING_SIZE)) {
+          || (map.maxsize - map.size) < AV_INPUT_BUFFER_PADDING_SIZE)) {
     /* add padding */
-    if (ffmpegdec->padded_size < bsize + FF_INPUT_BUFFER_PADDING_SIZE) {
-      ffmpegdec->padded_size = bsize + FF_INPUT_BUFFER_PADDING_SIZE;
+    if (ffmpegdec->padded_size < bsize + AV_INPUT_BUFFER_PADDING_SIZE) {
+      ffmpegdec->padded_size = bsize + AV_INPUT_BUFFER_PADDING_SIZE;
       ffmpegdec->padded = g_realloc (ffmpegdec->padded, ffmpegdec->padded_size);
       GST_LOG_OBJECT (ffmpegdec, "resized padding buffer to %d",
           ffmpegdec->padded_size);
@@ -755,7 +755,7 @@ gst_ffmpegauddec_handle_frame (GstAudioD
     GST_CAT_TRACE_OBJECT (CAT_PERFORMANCE, ffmpegdec,
         "Copy input to add padding");
     memcpy (ffmpegdec->padded, bdata, bsize);
-    memset (ffmpegdec->padded + bsize, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+    memset (ffmpegdec->padded + bsize, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
     bdata = ffmpegdec->padded;
     do_padding = TRUE;
@@ -764,7 +764,7 @@ gst_ffmpegauddec_handle_frame (GstAudioD
   }
 
   do {
-    guint8 tmp_padding[FF_INPUT_BUFFER_PADDING_SIZE];
+    guint8 tmp_padding[AV_INPUT_BUFFER_PADDING_SIZE];
 
     data = bdata;
     size = bsize;
@@ -773,15 +773,15 @@ gst_ffmpegauddec_handle_frame (GstAudioD
       /* add temporary padding */
       GST_CAT_TRACE_OBJECT (CAT_PERFORMANCE, ffmpegdec,
           "Add temporary input padding");
-      memcpy (tmp_padding, data + size, FF_INPUT_BUFFER_PADDING_SIZE);
-      memset (data + size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+      memcpy (tmp_padding, data + size, AV_INPUT_BUFFER_PADDING_SIZE);
+      memset (data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
     }
 
     /* decode a frame of audio now */
     len = gst_ffmpegauddec_frame (ffmpegdec, data, size, &have_data, &ret);
 
     if (do_padding) {
-      memcpy (data + size, tmp_padding, FF_INPUT_BUFFER_PADDING_SIZE);
+      memcpy (data + size, tmp_padding, AV_INPUT_BUFFER_PADDING_SIZE);
     }
 
     if (ret != GST_FLOW_OK) {
--- gst-libav-1.12.4/ext/libav/gstavaudenc.c.omv~	2018-01-11 15:21:20.580458067 +0100
+++ gst-libav-1.12.4/ext/libav/gstavaudenc.c	2018-01-11 15:22:03.676649717 +0100
@@ -283,7 +283,7 @@ gst_ffmpegaudenc_set_format (GstAudioEnc
   }
 
   /* some other defaults */
-  ffmpegaudenc->context->rc_strategy = 2;
+  //ffmpegaudenc->context->rc_strategy = 2;
   ffmpegaudenc->context->b_frame_strategy = 0;
   ffmpegaudenc->context->coder_type = 0;
   ffmpegaudenc->context->context_model = 0;
@@ -330,7 +330,7 @@ gst_ffmpegaudenc_set_format (GstAudioEnc
             oclass->in_plugin) < 0)
       GST_DEBUG_OBJECT (ffmpegaudenc, "Failed to set context defaults");
 
-    if ((oclass->in_plugin->capabilities & CODEC_CAP_EXPERIMENTAL) &&
+    if ((oclass->in_plugin->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
         ffmpegaudenc->compliance != GST_FFMPEG_EXPERIMENTAL) {
       GST_ELEMENT_ERROR (ffmpegaudenc, LIBRARY, SETTINGS,
           ("Codec is experimental, but settings don't allow encoders to "
@@ -602,7 +602,7 @@ gst_ffmpegaudenc_encode_audio (GstFFMpeg
         pkt->size, 0, pkt->size, pkt, gst_ffmpegaudenc_free_avpacket);
 
     codec = ffmpegaudenc->context->codec;
-    if ((codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE) || !buffer) {
+    if ((codec->capabilities & AV_CODEC_CAP_VARIABLE_FRAME_SIZE) || !buffer) {
       /* FIXME: Not really correct, as -1 means "all the samples we got
          given so far", which may not be true depending on the codec,
          but we have no way to know AFAICT */
@@ -626,7 +626,7 @@ gst_ffmpegaudenc_drain (GstFFMpegAudEnc
 
   oclass = (GstFFMpegAudEncClass *) (G_OBJECT_GET_CLASS (ffmpegaudenc));
 
-  if (oclass->in_plugin->capabilities & CODEC_CAP_DELAY) {
+  if (oclass->in_plugin->capabilities & AV_CODEC_CAP_DELAY) {
     gint have_data, try = 0;
 
     GST_LOG_OBJECT (ffmpegaudenc,
--- gst-libav-1.12.4/ext/libav/gstavcfg.c.omv~	2018-01-11 15:27:46.459125761 +0100
+++ gst-libav-1.12.4/ext/libav/gstavcfg.c	2018-01-11 15:33:36.993997370 +0100
@@ -42,9 +42,9 @@ gst_ffmpeg_pass_get_type (void)
   if (!ffmpeg_pass_type) {
     static const GEnumValue ffmpeg_passes[] = {
       {0, "Constant Bitrate Encoding", "cbr"},
-      {CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
-      {CODEC_FLAG_PASS1, "VBR Encoding - Pass 1", "pass1"},
-      {CODEC_FLAG_PASS2, "VBR Encoding - Pass 2", "pass2"},
+      {AV_CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
+      {AV_CODEC_FLAG_PASS1, "VBR Encoding - Pass 1", "pass1"},
+      {AV_CODEC_FLAG_PASS2, "VBR Encoding - Pass 2", "pass2"},
       {0, NULL, NULL},
     };
 
@@ -66,7 +66,7 @@ gst_ffmpeg_lim_pass_get_type (void)
   if (!ffmpeg_lim_pass_type) {
     static const GEnumValue ffmpeg_lim_passes[] = {
       {0, "Constant Bitrate Encoding", "cbr"},
-      {CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
+      {AV_CODEC_FLAG_QSCALE, "Constant Quantizer", "quant"},
       {0, NULL, NULL},
     };
 
@@ -260,21 +260,21 @@ gst_ffmpeg_flags_get_type (void)
   /* FIXME: This needs some serious resyncing with avcodec.h */
   if (!ffmpeg_flags_type) {
     static const GFlagsValue ffmpeg_flags[] = {
-      {CODEC_FLAG_QSCALE, "Use fixed qscale", "qscale"},
-      {CODEC_FLAG_4MV, "Allow 4 MV per MB", "4mv"},
-      {CODEC_FLAG_QPEL, "Quartel Pel Motion Compensation", "qpel"},
-      {CODEC_FLAG_GMC, "GMC", "gmc"},
-      {CODEC_FLAG_MV0, "Always try a MB with MV (0,0)", "mv0"},
-      {CODEC_FLAG_LOOP_FILTER, "Loop filter", "loop-filter"},
-      {CODEC_FLAG_GRAY, "Only decode/encode grayscale", "gray"},
-      {CODEC_FLAG_NORMALIZE_AQP,
-          "Normalize Adaptive Quantization (masking, etc)", "aqp"},
-      {CODEC_FLAG_GLOBAL_HEADER,
+      {AV_CODEC_FLAG_QSCALE, "Use fixed qscale", "qscale"},
+      {AV_CODEC_FLAG_4MV, "Allow 4 MV per MB", "4mv"},
+      {AV_CODEC_FLAG_QPEL, "Quartel Pel Motion Compensation", "qpel"},
+      //{AV_CODEC_FLAG_GMC, "GMC", "gmc"},
+      //{AV_CODEC_FLAG_MV0, "Always try a MB with MV (0,0)", "mv0"},
+      {AV_CODEC_FLAG_LOOP_FILTER, "Loop filter", "loop-filter"},
+      {AV_CODEC_FLAG_GRAY, "Only decode/encode grayscale", "gray"},
+      //{AV_CODEC_FLAG_NORMALIZE_AQP,
+      //    "Normalize Adaptive Quantization (masking, etc)", "aqp"},
+      {AV_CODEC_FLAG_GLOBAL_HEADER,
             "Global headers in extradata instead of every keyframe",
           "global-headers"},
-      {CODEC_FLAG_AC_PRED, "H263 Advanced Intra Coding / MPEG4 AC prediction",
+      {AV_CODEC_FLAG_AC_PRED, "H263 Advanced Intra Coding / MPEG4 AC prediction",
           "aic"},
-      {CODEC_FLAG_CLOSED_GOP, "Closed GOP", "closedgop"},
+      {AV_CODEC_FLAG_CLOSED_GOP, "Closed GOP", "closedgop"},
       {0, NULL, NULL},
     };
 
@@ -490,16 +490,16 @@ gst_ffmpeg_cfg_init (void)
   pspec = g_param_spec_float ("rc-qsquish", "Ratecontrol Limiting Method",
       "0 means limit by clipping, otherwise use nice continuous function",
       0, 99.0f, 1.0f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_qsquish, FALSE, mpeg, NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.rc_qsquish, FALSE, mpeg, NULL);
 
   pspec = g_param_spec_float ("rc-qmod-amp", "Ratecontrol Mod",
       "Ratecontrol Mod", 0, 99.0f, 0,
       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_qmod_amp, FALSE, mpeg, NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.rc_qmod_amp, FALSE, mpeg, NULL);
 
   pspec = g_param_spec_int ("rc-qmod-freq", "Ratecontrol Freq",
       "Ratecontrol Freq", 0, 0, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_qmod_freq, FALSE, mpeg, NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.rc_qmod_freq, FALSE, mpeg, NULL);
 
   pspec = g_param_spec_int ("rc-buffer-size", "Ratecontrol Buffer Size",
       "Decoder bitstream buffer size", 0, G_MAXINT, 0,
@@ -510,8 +510,8 @@ gst_ffmpeg_cfg_init (void)
       g_param_spec_float ("rc-buffer-aggressivity",
       "Ratecontrol Buffer Aggressivity", "Ratecontrol Buffer Aggressivity", 0,
       99.0f, 1.0f, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_buffer_aggressivity, FALSE, mpeg,
-      NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.rc_buffer_aggressivity, FALSE, mpeg,
+  //    NULL);
 
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT (57, 3, 0)
   pspec = g_param_spec_int ("rc-max-rate", "Ratecontrol Maximum Bitrate",
@@ -534,12 +534,12 @@ gst_ffmpeg_cfg_init (void)
       "Initial Complexity for Pass 1 Ratecontrol",
       "Initial Complexity for Pass 1 Ratecontrol", 0, 9999999.0f, 0,
       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_initial_cplx, FALSE, mpeg, NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.rc_initial_cplx, FALSE, mpeg, NULL);
 
   pspec = g_param_spec_string ("rc-eq", "Ratecontrol Equation",
       "Ratecontrol Equation", "tex^qComp",
       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.rc_eq, FALSE, mpeg, NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.rc_eq, FALSE, mpeg, NULL);
 
   pspec = g_param_spec_float ("b-quant-factor", "B-Quantizer Factor",
       "Factor in B-Frame Quantizer Computation",
@@ -630,6 +630,7 @@ gst_ffmpeg_cfg_init (void)
       0, 16000, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
   gst_ffmpeg_add_pspec (pspec, config.me_range, FALSE, mpeg, NULL);
 
+#if 0
   pspec = g_param_spec_int ("intra-quant-bias",
       "Intra Quantizer Bias",
       "Intra Quantizer Bias",
@@ -642,7 +643,8 @@ gst_ffmpeg_cfg_init (void)
       "Inter Quantizer Bias",
       -1000000, 1000000, FF_DEFAULT_QUANT_BIAS,
       G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
-  gst_ffmpeg_add_pspec (pspec, config.inter_quant_bias, FALSE, mpeg, NULL);
+  //gst_ffmpeg_add_pspec (pspec, config.inter_quant_bias, FALSE, mpeg, NULL);
+#endif
 
   pspec = g_param_spec_int ("noise-reduction",
       "Noise Reduction",
--- gst-libav-1.12.4/ext/libav/gstavcodecmap.c.omv~	2018-01-11 15:18:42.251699705 +0100
+++ gst-libav-1.12.4/ext/libav/gstavcodecmap.c	2018-01-11 15:20:44.631293749 +0100
@@ -818,10 +818,10 @@ gst_ffmpeg_codecid_to_caps (enum AVCodec
       if (encode && context) {
 
         gst_caps_set_simple (caps,
-            "annex-f", G_TYPE_BOOLEAN, context->flags & CODEC_FLAG_4MV,
-            "annex-j", G_TYPE_BOOLEAN, context->flags & CODEC_FLAG_LOOP_FILTER,
-            "annex-i", G_TYPE_BOOLEAN, context->flags & CODEC_FLAG_AC_PRED,
-            "annex-t", G_TYPE_BOOLEAN, context->flags & CODEC_FLAG_AC_PRED,
+            "annex-f", G_TYPE_BOOLEAN, context->flags & AV_CODEC_FLAG_4MV,
+            "annex-j", G_TYPE_BOOLEAN, context->flags & AV_CODEC_FLAG_LOOP_FILTER,
+            "annex-i", G_TYPE_BOOLEAN, context->flags & AV_CODEC_FLAG_AC_PRED,
+            "annex-t", G_TYPE_BOOLEAN, context->flags & AV_CODEC_FLAG_AC_PRED,
             NULL);
       }
       break;
@@ -3185,7 +3185,7 @@ gst_ffmpeg_caps_with_codecid (enum AVCod
       GST_DEBUG ("copy codec_data");
       context->extradata =
           av_mallocz (GST_ROUND_UP_16 (map.size +
-              FF_INPUT_BUFFER_PADDING_SIZE));
+              AV_INPUT_BUFFER_PADDING_SIZE));
       memcpy (context->extradata, map.data, map.size);
       context->extradata_size = map.size;
     }
@@ -3209,7 +3209,7 @@ gst_ffmpeg_caps_with_codecid (enum AVCod
     {
       const gchar *mime = gst_structure_get_name (str);
 
-      context->flags |= CODEC_FLAG_4MV;
+      context->flags |= AV_CODEC_FLAG_4MV;
 
       if (!strcmp (mime, "video/x-divx"))
         context->codec_tag = GST_MAKE_FOURCC ('D', 'I', 'V', 'X');
@@ -3221,7 +3221,7 @@ gst_ffmpeg_caps_with_codecid (enum AVCod
         profile = gst_structure_get_string (str, "profile");
         if (profile) {
           if (g_strcmp0 (profile, "advanced-simple") == 0)
-            context->flags |= CODEC_FLAG_GMC | CODEC_FLAG_QPEL;
+            context->flags |= /*AV_CODEC_FLAG_GMC |*/ AV_CODEC_FLAG_QPEL;
         }
       }
       break;
@@ -3327,18 +3327,18 @@ gst_ffmpeg_caps_with_codecid (enum AVCod
       gboolean val;
 
       if (!gst_structure_get_boolean (str, "annex-f", &val) || val)
-        context->flags |= CODEC_FLAG_4MV;
+        context->flags |= AV_CODEC_FLAG_4MV;
       else
-        context->flags &= ~CODEC_FLAG_4MV;
+        context->flags &= ~AV_CODEC_FLAG_4MV;
       if ((!gst_structure_get_boolean (str, "annex-i", &val) || val) &&
           (!gst_structure_get_boolean (str, "annex-t", &val) || val))
-        context->flags |= CODEC_FLAG_AC_PRED;
+        context->flags |= AV_CODEC_FLAG_AC_PRED;
       else
-        context->flags &= ~CODEC_FLAG_AC_PRED;
+        context->flags &= ~AV_CODEC_FLAG_AC_PRED;
       if (!gst_structure_get_boolean (str, "annex-j", &val) || val)
-        context->flags |= CODEC_FLAG_LOOP_FILTER;
+        context->flags |= AV_CODEC_FLAG_LOOP_FILTER;
       else
-        context->flags &= ~CODEC_FLAG_LOOP_FILTER;
+        context->flags &= ~AV_CODEC_FLAG_LOOP_FILTER;
       break;
     }
     case AV_CODEC_ID_ADPCM_G726:
--- gst-libav-1.12.4/ext/libav/gstav.c.omv~	2018-01-11 15:18:13.672552262 +0100
+++ gst-libav-1.12.4/ext/libav/gstav.c	2018-01-11 15:18:15.485561723 +0100
@@ -30,7 +30,6 @@
 
 #include <libavcodec/avcodec.h>
 #include <libavformat/avformat.h>
-#include <libavfilter/avfiltergraph.h>
 
 #include "gstav.h"
 #include "gstavutils.h"
--- gst-libav-1.12.4/ext/libav/gstavviddec.c.omv~	2018-01-11 15:20:59.292361272 +0100
+++ gst-libav-1.12.4/ext/libav/gstavviddec.c	2018-01-11 15:27:24.074011420 +0100
@@ -237,7 +237,7 @@ gst_ffmpegviddec_class_init (GstFFMpegVi
           DEFAULT_OUTPUT_CORRUPT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   caps = klass->in_plugin->capabilities;
-  if (caps & (CODEC_CAP_FRAME_THREADS | CODEC_CAP_SLICE_THREADS)) {
+  if (caps & (AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS)) {
     g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_MAX_THREADS,
         g_param_spec_int ("max-threads", "Maximum decode threads",
             "Maximum number of worker threads to spawn. (0 = auto)",
@@ -365,7 +365,7 @@ gst_ffmpegviddec_open (GstFFMpegVidDec *
       oclass->in_plugin->name, oclass->in_plugin->id);
 
   gst_ffmpegviddec_context_set_flags (ffmpegdec->context,
-      CODEC_FLAG_OUTPUT_CORRUPT, ffmpegdec->output_corrupt);
+      AV_CODEC_FLAG_OUTPUT_CORRUPT, ffmpegdec->output_corrupt);
 
   return TRUE;
 
@@ -495,7 +495,7 @@ gst_ffmpegviddec_set_format (GstVideoDec
     gboolean is_live;
 
     if (ffmpegdec->max_threads == 0) {
-      if (!(oclass->in_plugin->capabilities & CODEC_CAP_AUTO_THREADS))
+      if (!(oclass->in_plugin->capabilities & AV_CODEC_CAP_AUTO_THREADS))
         ffmpegdec->context->thread_count = gst_ffmpeg_auto_max_threads ();
       else
         ffmpegdec->context->thread_count = 0;
@@ -624,9 +624,11 @@ gst_ffmpegvideodec_prepare_dr_pool (GstF
   avcodec_align_dimensions2 (ffmpegdec->context, &width, &height,
       linesize_align);
 
-  if (ffmpegdec->context->flags & CODEC_FLAG_EMU_EDGE)
+#if 0
+  if (ffmpegdec->context->flags & AV_CODEC_FLAG_EMU_EDGE)
     edge = 0;
   else
+#endif
     edge = avcodec_get_edge_width ();
 
   /* increase the size for the padding */
@@ -732,7 +734,7 @@ gst_ffmpegviddec_can_direct_render (GstF
     return FALSE;
 
   oclass = (GstFFMpegVidDecClass *) (G_OBJECT_GET_CLASS (ffmpegdec));
-  return ((oclass->in_plugin->capabilities & CODEC_CAP_DR1) == CODEC_CAP_DR1);
+  return ((oclass->in_plugin->capabilities & AV_CODEC_CAP_DR1) == AV_CODEC_CAP_DR1);
 }
 
 /* called when ffmpeg wants us to allocate a buffer to write the decoded frame
@@ -1769,7 +1771,7 @@ gst_ffmpegviddec_drain (GstVideoDecoder
 
   oclass = (GstFFMpegVidDecClass *) (G_OBJECT_GET_CLASS (ffmpegdec));
 
-  if (oclass->in_plugin->capabilities & CODEC_CAP_DELAY) {
+  if (oclass->in_plugin->capabilities & AV_CODEC_CAP_DELAY) {
     gint have_data, len;
     GstFlowReturn ret;
 
@@ -1815,10 +1817,10 @@ gst_ffmpegviddec_handle_frame (GstVideoD
   bsize = minfo.size;
 
   if (bsize > 0 && (!GST_MEMORY_IS_ZERO_PADDED (minfo.memory)
-          || (minfo.maxsize - minfo.size) < FF_INPUT_BUFFER_PADDING_SIZE)) {
+          || (minfo.maxsize - minfo.size) < AV_INPUT_BUFFER_PADDING_SIZE)) {
     /* add padding */
-    if (ffmpegdec->padded_size < bsize + FF_INPUT_BUFFER_PADDING_SIZE) {
-      ffmpegdec->padded_size = bsize + FF_INPUT_BUFFER_PADDING_SIZE;
+    if (ffmpegdec->padded_size < bsize + AV_INPUT_BUFFER_PADDING_SIZE) {
+      ffmpegdec->padded_size = bsize + AV_INPUT_BUFFER_PADDING_SIZE;
       ffmpegdec->padded = g_realloc (ffmpegdec->padded, ffmpegdec->padded_size);
       GST_LOG_OBJECT (ffmpegdec, "resized padding buffer to %d",
           ffmpegdec->padded_size);
@@ -1826,7 +1828,7 @@ gst_ffmpegviddec_handle_frame (GstVideoD
     GST_CAT_TRACE_OBJECT (CAT_PERFORMANCE, ffmpegdec,
         "Copy input to add padding");
     memcpy (ffmpegdec->padded, bdata, bsize);
-    memset (ffmpegdec->padded + bsize, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+    memset (ffmpegdec->padded + bsize, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
     bdata = ffmpegdec->padded;
     do_padding = TRUE;
@@ -1835,7 +1837,7 @@ gst_ffmpegviddec_handle_frame (GstVideoD
   }
 
   do {
-    guint8 tmp_padding[FF_INPUT_BUFFER_PADDING_SIZE];
+    guint8 tmp_padding[AV_INPUT_BUFFER_PADDING_SIZE];
 
     /* parse, if at all possible */
     data = bdata;
@@ -1845,8 +1847,8 @@ gst_ffmpegviddec_handle_frame (GstVideoD
       /* add temporary padding */
       GST_CAT_TRACE_OBJECT (CAT_PERFORMANCE, ffmpegdec,
           "Add temporary input padding");
-      memcpy (tmp_padding, data + size, FF_INPUT_BUFFER_PADDING_SIZE);
-      memset (data + size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+      memcpy (tmp_padding, data + size, AV_INPUT_BUFFER_PADDING_SIZE);
+      memset (data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
     }
 
     /* decode a frame of audio/video now */
@@ -1862,7 +1864,7 @@ gst_ffmpegviddec_handle_frame (GstVideoD
     }
 
     if (do_padding) {
-      memcpy (data + size, tmp_padding, FF_INPUT_BUFFER_PADDING_SIZE);
+      memcpy (data + size, tmp_padding, AV_INPUT_BUFFER_PADDING_SIZE);
     }
 
     if (len == 0 && have_data == 0) {
@@ -2143,7 +2145,7 @@ gst_ffmpegviddec_propose_allocation (Gst
   gst_allocation_params_init (&params);
   params.flags = GST_MEMORY_FLAG_ZERO_PADDED;
   params.align = DEFAULT_STRIDE_ALIGN;
-  params.padding = FF_INPUT_BUFFER_PADDING_SIZE;
+  params.padding = AV_INPUT_BUFFER_PADDING_SIZE;
   /* we would like to have some padding so that we don't have to
    * memcpy. We don't suggest an allocator. */
   gst_query_add_allocation_param (query, NULL, &params);
--- gst-libav-1.12.4/ext/libav/gstavvidenc.c.omv~	2018-01-11 15:22:17.940712267 +0100
+++ gst-libav-1.12.4/ext/libav/gstavvidenc.c	2018-01-11 15:25:42.802605404 +0100
@@ -74,12 +74,14 @@ gst_ffmpegvidenc_me_method_get_type (voi
 {
   static GType ffmpegenc_me_method_type = 0;
   static GEnumValue ffmpegenc_me_methods[] = {
+#if 0
     {ME_ZERO, "None (Very low quality)", "zero"},
     {ME_FULL, "Full (Slow, unmaintained)", "full"},
     {ME_LOG, "Logarithmic (Low quality, unmaintained)", "logarithmic"},
     {ME_PHODS, "phods (Low quality, unmaintained)", "phods"},
     {ME_EPZS, "EPZS (Best quality, Fast)", "epzs"},
     {ME_X1, "X1 (Experimental)", "x1"},
+#endif
     {0, NULL, NULL},
   };
   if (!ffmpegenc_me_method_type) {
@@ -203,7 +205,7 @@ gst_ffmpegvidenc_class_init (GstFFMpegVi
           DEFAULT_VIDEO_GOP_SIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_ME_METHOD,
       g_param_spec_enum ("me-method", "ME Method", "Motion Estimation Method",
-          GST_TYPE_ME_METHOD, ME_EPZS,
+          GST_TYPE_ME_METHOD, 0 /*ME_EPZS*/,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_BUFSIZE,
@@ -216,7 +218,7 @@ gst_ffmpegvidenc_class_init (GstFFMpegVi
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   caps = klass->in_plugin->capabilities;
-  if (caps & (CODEC_CAP_FRAME_THREADS | CODEC_CAP_SLICE_THREADS)) {
+  if (caps & (AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS)) {
     g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_MAX_THREADS,
         g_param_spec_int ("max-threads", "Maximum encode threads",
             "Maximum number of worker threads to spawn. (0 = auto)",
@@ -259,7 +261,7 @@ gst_ffmpegvidenc_init (GstFFMpegVidEnc *
   ffmpegenc->file = NULL;
 
   ffmpegenc->bitrate = DEFAULT_VIDEO_BITRATE;
-  ffmpegenc->me_method = ME_EPZS;
+  //ffmpegenc->me_method = ME_EPZS;
   ffmpegenc->buffer_size = 512 * 1024;
   ffmpegenc->gop_size = DEFAULT_VIDEO_GOP_SIZE;
   ffmpegenc->rtp_payload_size = 0;
@@ -321,12 +323,12 @@ gst_ffmpegvidenc_set_format (GstVideoEnc
   ffmpegenc->context->bit_rate = ffmpegenc->bitrate;
   ffmpegenc->context->bit_rate_tolerance = ffmpegenc->bitrate;
   ffmpegenc->context->gop_size = ffmpegenc->gop_size;
-  ffmpegenc->context->me_method = ffmpegenc->me_method;
+  //ffmpegenc->context->me_method = ffmpegenc->me_method;
   GST_DEBUG_OBJECT (ffmpegenc, "Setting avcontext to bitrate %d, gop_size %d",
       ffmpegenc->bitrate, ffmpegenc->gop_size);
 
   if (ffmpegenc->max_threads == 0) {
-    if (!(oclass->in_plugin->capabilities & CODEC_CAP_AUTO_THREADS))
+    if (!(oclass->in_plugin->capabilities & AV_CODEC_CAP_AUTO_THREADS))
       ffmpegenc->context->thread_count = gst_ffmpeg_auto_max_threads ();
     else
       ffmpegenc->context->thread_count = 0;
@@ -343,16 +345,16 @@ gst_ffmpegvidenc_set_format (GstVideoEnc
   gst_ffmpeg_cfg_fill_context (ffmpegenc, ffmpegenc->context);
 
   /* then handle some special cases */
-  ffmpegenc->context->lmin = (ffmpegenc->lmin * FF_QP2LAMBDA + 0.5);
-  ffmpegenc->context->lmax = (ffmpegenc->lmax * FF_QP2LAMBDA + 0.5);
+  //ffmpegenc->context->lmin = (ffmpegenc->lmin * FF_QP2LAMBDA + 0.5);
+  //ffmpegenc->context->lmax = (ffmpegenc->lmax * FF_QP2LAMBDA + 0.5);
 
   if (ffmpegenc->interlaced) {
     ffmpegenc->context->flags |=
-        CODEC_FLAG_INTERLACED_DCT | CODEC_FLAG_INTERLACED_ME;
+        AV_CODEC_FLAG_INTERLACED_DCT | AV_CODEC_FLAG_INTERLACED_ME;
   }
 
   /* some other defaults */
-  ffmpegenc->context->rc_strategy = 2;
+  //ffmpegenc->context->rc_strategy = 2;
   ffmpegenc->context->b_frame_strategy = 0;
   ffmpegenc->context->coder_type = 0;
   ffmpegenc->context->context_model = 0;
@@ -362,18 +364,18 @@ gst_ffmpegvidenc_set_format (GstVideoEnc
   ffmpegenc->context->flags |= ffmpegenc->pass;
   switch (ffmpegenc->pass) {
       /* some additional action depends on type of pass */
-    case CODEC_FLAG_QSCALE:
+    case AV_CODEC_FLAG_QSCALE:
       ffmpegenc->context->global_quality
           = ffmpegenc->picture->quality = FF_QP2LAMBDA * ffmpegenc->quantizer;
       break;
-    case CODEC_FLAG_PASS1:     /* need to prepare a stats file */
+    case AV_CODEC_FLAG_PASS1:     /* need to prepare a stats file */
       /* we don't close when changing caps, fingers crossed */
       if (!ffmpegenc->file)
         ffmpegenc->file = g_fopen (ffmpegenc->filename, "w");
       if (!ffmpegenc->file)
         goto open_file_err;
       break;
-    case CODEC_FLAG_PASS2:
+    case AV_CODEC_FLAG_PASS2:
     {                           /* need to read the whole stats file ! */
       gsize size;
 
